<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Terminal List</title>
  <!-- PWA refs -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#32cd32">
  <style>
    :root{
      --bg: #000;
      --fg: #32cd32; /* limegreen */
      --border: #32cd32;
      --font: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --header-h: 60px;
      --input-h: 52px;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: var(--font);
      overflow: hidden;
    }
    #header{
      position: fixed; top: 0; left: 0; right: 0;
      height: var(--header-h);
      padding: 6px 10px;
      border-bottom: 1px solid var(--border);
      background: var(--bg);
      z-index: 1000;
      line-height: 1.2;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    #header .left{ display: flex; flex-direction: column; }
    #installWrap{ display: flex; align-items: center; gap: 8px; }
    #installStatus{ font-size: 12px; opacity: .75; }
    #installBtn{
      background: transparent;
      color: var(--fg);
      border: 1px solid var(--border);
      padding: 6px 10px;
      font-family: var(--font);
      cursor: pointer;
      opacity: .6;
    }
    #installBtn.enabled{ opacity: 1; }
    #output{
      position: absolute;
      top: var(--header-h);
      left: 0; right: 0;
      bottom: calc(var(--input-h) + env(safe-area-inset-bottom));
      padding: 20px 10px 10px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      box-sizing: border-box;
    }
    #input-bar{
      position: fixed; left: 0; right: 0;
      height: var(--input-h);
      bottom: env(safe-area-inset-bottom);
      border-top: 1px solid var(--border);
      background: var(--bg);
      z-index: 1000;
      display: flex; align-items: center; gap: 8px;
      padding: 6px 10px; box-sizing: border-box;
      transform: translateY(0);
      will-change: transform;
    }
    #prompt-label{ user-select: none; white-space: pre; }
    #command{
      flex: 1; min-width: 0;
      background: transparent; color: var(--fg);
      border: 0; outline: none; caret-color: var(--fg);
      font-family: var(--font); font-size: 16px;
    }
    .line{ white-space: pre-wrap; word-break: break-word; }
    .muted{ opacity: 0.85; }
    .error{ color: #ff4d4d; }
    .ok{ color: #7fffd4; }
    .task-done{ opacity: 0.7; text-decoration: line-through; }
    /* Modal + Install Help */
    #modal, #install-help{
      position: fixed; inset: 0; display: none;
      align-items: center; justify-content: center;
      background: rgba(0,0,0,0.92);
      z-index: 2000;
    }
    .card{
      border: 1px solid var(--border);
      padding: 16px 20px;
      width: min(560px, calc(100% - 40px));
      background: #000;
      box-sizing: border-box;
    }
    .row{ display:flex; gap:10px; margin-top:14px; justify-content:flex-end; }
    button.terminal{
      background: transparent; color: var(--fg);
      border: 1px solid var(--border);
      padding: 8px 14px; font-family: var(--font);
      cursor: pointer;
    }
    button.terminal:hover{ outline: 1px dashed var(--border); }
  .cursor {
    display: inline-block;
    width: 10px;
    height: 1.2em;
    background-color: #32cd32; /* terminal green */
    margin-left: 2px;
    animation: blink 1s steps(1) infinite;
    vertical-align: bottom;
  }

  @keyframes blink {
    50% {
      opacity: 0;
    }
  }
  </style>
</head>
<body>
  <div id="header">
    <div class="left">
      <div class="title">TERMINAL LIST<span class="cursor"></span></div>
      <div class="subtitle">Type HELP to begin</div>
    </div>
    <div id="installWrap">
      <span id="installStatus" class="muted"></span>
      <button id="installBtn" aria-label="Install app">Install</button>
    </div>
  </div>

  <div id="output" role="log" aria-live="polite"></div>

  <div id="input-bar" role="group" aria-label="Command input">
    <span id="prompt-label">&gt; </span>
    <input id="command" name="command" type="text" inputmode="text" autocapitalize="sentences"
           spellcheck="true" placeholder="enter command..." autocomplete="off" />

  </div>

  <div id="modal" role="dialog" aria-modal="true" aria-labelledby="wipe-title">
    <div class="card">
      <div id="wipe-title" class="line">Confirm WIPE</div>
      <div class="line" style="margin-top:6px">Are you sure you want to WIPE all data?</div>
      <div class="row">
        <button class="terminal" id="btn-cancel">Cancel</button>
        <button class="terminal" id="btn-confirm">WIPE</button>
      </div>
    </div>
  </div>

  <div id="install-help" role="dialog" aria-modal="true" aria-labelledby="install-title">
    <div class="card">
      <div id="install-title" class="line">Install Help</div>
      <div class="line" style="margin-top:6px">
        The browser didn‚Äôt expose the install prompt yet.
      </div>
      <div class="line" style="margin-top:6px">
          Ensure: <code>manifest.webmanifest</code> (with 192/512 icons) is reachable, a <code>sw.js</code> is registered and controlling this page, and you‚Äôre on HTTPS or localhost.
      </div>
      <div class="line" style="margin-top:6px">
        iOS Safari: use Share ‚Üí ‚ÄúAdd to Home Screen‚Äù (no programmatic prompt on iOS).
      </div>
      <div class="row">
        <button class="terminal" id="install-close">Close</button>
      </div>
    </div>
  </div>
  
  <script src="https://apis.google.com/js/api.js"></script>

  <script src="features.js"></script>
  <script>
    /************
     * STORAGE
     ************/
    const STORE_KEY_V2 = 'terminal-list-state-v2'; // {items:[], notes:[]} or {version,enc:{}}
    const STORE_KEY_V1 = 'terminal-list-items-v1'; // legacy items-only

    const enc = new TextEncoder();
    const dec = new TextDecoder();
    function b64(buf){ return btoa(String.fromCharCode(...new Uint8Array(buf))); }
    function b64ToBuf(str){ return Uint8Array.from(atob(str), c=>c.charCodeAt(0)); }
    async function deriveKey(pass, saltBytes){
      const baseKey = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
      return crypto.subtle.deriveKey(
        { name:'PBKDF2', salt: saltBytes, iterations:200000, hash:'SHA-256' },
        baseKey,
        { name:'AES-GCM', length:256 },
        false,
        ['encrypt','decrypt']
      );
    }

    let passKey = null; // CryptoKey when unlocked
    let passSalt = null; // base64 string
    let locked = false;

    function loadState(){
      try{
        const raw = localStorage.getItem(STORE_KEY_V2);
        if (raw){
          const obj = JSON.parse(raw);
          if (obj && obj.enc){
            // encrypted payload present
            locked = true;
            passSalt = obj.enc.salt;
            return { items: [], notes: [] };
          }
          if (obj && Array.isArray(obj.items) && Array.isArray(obj.notes)){
            return obj;
          }
        }
      }catch{}
      try{
        const raw1 = localStorage.getItem(STORE_KEY_V1);
        if (raw1){
          const items = JSON.parse(raw1) || [];
          const state = { items, notes: [] };
          saveState(state);
          return state;
        }
      }catch{}
      return { items: [], notes: [] };
    }
    async function saveState(state){
      try{
        if (passKey){
          const iv = crypto.getRandomValues(new Uint8Array(12));
          const data = enc.encode(JSON.stringify({ items: state.items, notes: state.notes }));
          const buf = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, passKey, data);
          const payload = { version: 3, enc: { v:1, salt: passSalt, iv: b64(iv), data: b64(buf) } };
          localStorage.setItem(STORE_KEY_V2, JSON.stringify(payload));
        } else {
          localStorage.setItem(STORE_KEY_V2, JSON.stringify({ items: state.items, notes: state.notes }));
        }
      }catch(err){ console.error(err); }
    }
    function makeId(){ return Math.random().toString(36).slice(2,8); }

    let state = loadState();
    let items = state.items;
    let needsNoteMigration = false;
    let notes = state.notes.map(n=>{
      if (!n.body && n.text) needsNoteMigration = true;
      return {
        id: n.id,
        title: n.title || '',
        description: n.description || '',
        link: n.link || '',
        body: n.body || n.text || '',
        tags: n.tags || [],
        taskId: n.taskId || null,
        createdAt: n.createdAt,
        updatedAt: n.updatedAt,
      };
    });
    state.notes = notes;
    // expose notes array for feature helpers
    window.notes = notes;
    if (needsNoteMigration) saveNotes(notes);

    // Service Worker registration and notification timers
    let swRegistration = null;
    const dueTimers = new Map();

    async function requestNotificationPermission(){
      if (!('Notification' in window)) return;
      if (Notification.permission === 'default'){
        try{ await Notification.requestPermission(); }catch(e){}
      }
    }

    function scheduleTaskNotification(t){
      // Clear previous timer if any
      if (dueTimers.has(t.id)){
        clearTimeout(dueTimers.get(t.id));
        dueTimers.delete(t.id);
      }
      if (!t.due || !swRegistration || Notification.permission !== 'granted') return;
      const dueTime = new Date(t.due + 'T00:00:00');
      const delay = dueTime.getTime() - Date.now();
      if (delay <= 0) return;
      const timer = setTimeout(()=>{
        swRegistration.showNotification('Task due', {
          body: t.text,
          tag: t.id,
          data: { id: t.id }
        });
      }, delay);
      dueTimers.set(t.id, timer);
    }

    function rescheduleAllNotifications(){
      items.forEach(scheduleTaskNotification);
    }

    function saveItems(v){ state.items = v; saveState(state); }
    function saveNotes(v){
      notes = v;
      window.notes = v;
      state.notes = v;
      saveState(state);
    }
    const THEME_KEY = 'terminal-theme';
    function applyTheme(t){
      const root = document.documentElement.style;
      root.setProperty('--bg', t.bg);
      root.setProperty('--fg', t.fg);
      root.setProperty('--border', t.border);
    }
    function loadTheme(){
      try{
        return JSON.parse(localStorage.getItem(THEME_KEY));
      }catch{}
      return null;
    }
    function saveTheme(t){
      localStorage.setItem(THEME_KEY, JSON.stringify(t));
    }
    const savedTheme = loadTheme();
    if (savedTheme) applyTheme(savedTheme);

    /************
     * UI HELPERS
     ************/
    const output = document.getElementById('output');
    const command = document.getElementById('command');
    let awaitingLine = false;
    const HISTORY_KEY = 'command-history';
    let history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
    let historyIndex = history.length;
    const modal = document.getElementById('modal');
    const btnCancel = document.getElementById('btn-cancel');
    const btnOK = document.getElementById('btn-confirm');

    function println(text, cls){
      const div = document.createElement('div');
      div.className = 'line' + (cls ? ' ' + cls : '');
      div.textContent = text;
      output.appendChild(div);
      output.scrollTop = output.scrollHeight;
    }
    function countNotesForTask(taskId){
      return notes.filter(n => n.taskId === taskId).length;
    }
    function printTask(t, indexShown){
      const box = t.done ? '‚òë' : '‚òê';
      const pri = t.pri === 'H' ? ' !H' : t.pri === 'M' ? ' !M' : t.pri === 'L' ? ' !L' : '';
      const tags = (t.tags||[]).map(s=>' @'+s).join('');
      const due = t.due ? ' ^' + t.due : '';
      const idx = typeof indexShown === 'number' ? '['+indexShown+'] ' : '';
      const noteCount = countNotesForTask(t.id);
      const noteBadge = noteCount ? ` [üìùx${noteCount}]` : '';
      const line = `${idx}(${t.id}) ${box} ${t.text}${tags}${due}${pri}${noteBadge}`;
      const div = document.createElement('div');
      div.className = 'line' + (t.done ? ' task-done' : '');
      div.textContent = line;
      output.appendChild(div);
    }
    function printList(arr, title){
      if (title) println(title, 'muted');
      if (!arr.length){ println('‚Äî no items ‚Äî', 'muted'); return; }
      arr.forEach((t,i)=>printTask(t,i+1));
      output.scrollTop = output.scrollHeight;
    }
    function printNote(n, indexShown){
      const idx = typeof indexShown === 'number' ? '['+indexShown+'] ' : '';
      const tags = (n.tags||[]).map(s=>' @'+s).join('');
      const taskLink = n.taskId ? ` linked:(${n.taskId})` : '';
      const line = `${idx}(${n.id}) üìù ${n.title || ''} ‚Äî ${n.description || ''}${tags}${taskLink}`;
      const div = document.createElement('div');
      div.className = 'line';
      div.textContent = line;
      output.appendChild(div);
    }
    function printNotes(arr, title){
      if (title) println(title, 'muted');
      if (!arr.length){ println('‚Äî no notes ‚Äî', 'muted'); return; }
      arr.forEach((n,i)=>printNote(n,i+1));
      output.scrollTop = output.scrollHeight;
    }

    /************
     * FILTER/RESOLUTION
     ************/
    function listFilteredTasks(filter, sortBy){
      let arr = [...items];
      if (sortBy === 'due') {
        arr.sort((a,b)=>{
          if (!a.due && !b.due) return a.createdAt - b.createdAt;
          if (!a.due) return 1;
          if (!b.due) return -1;
          if (a.due === b.due) return a.createdAt - b.createdAt;
          return a.due.localeCompare(b.due);
        });
      } else if (sortBy === 'pri') {
        const order = {H:0, M:1, L:2};
        arr.sort((a,b)=>{
          const pa = order[a.pri] ?? 3;
          const pb = order[b.pri] ?? 3;
          if (pa === pb) return a.createdAt - b.createdAt;
          return pa - pb;
        });
      } else {
        arr.sort((a,b)=>a.createdAt - b.createdAt);
      }
      if (!filter || filter==='open') arr = arr.filter(t=>!t.done);
      else if (filter==='done') arr = arr.filter(t=>t.done);
      else if (filter==='all') { }
      else if (filter.startsWith('@')) {
        const tag = filter.slice(1).toLowerCase();
        arr = arr.filter(t=>(t.tags||[]).map(s=>s.toLowerCase()).includes(tag));
      }
      return arr;
    }
    function listFilteredNotes(filter){
      let arr = [...notes];
      arr.sort((a,b)=>a.createdAt - b.createdAt);
      if (!filter || filter==='all') { /* no-op */ }
      else if (filter.startsWith('@')) {
        const tag = filter.slice(1).toLowerCase();
        arr = arr.filter(n=>(n.tags||[]).map(s=>s.toLowerCase()).includes(tag));
      } else if (filter.startsWith('task:')){
        const ref = filter.slice(5).trim();
        const t = resolveTaskRef(ref, lastTaskListCache);
        if (t) arr = arr.filter(n=>n.taskId === t.id);
        else arr = [];
      }
      return arr;
    }
    function resolveTaskRef(ref, currentList){
      if (!ref) return null;
      const byId = items.find(t=>t.id === ref);
      if (byId) return byId;
      const n = parseInt(ref,10);
      if (!isNaN(n) && currentList && n>=1 && n<=currentList.length) return currentList[n-1];
      if (!isNaN(n) && n>=1 && n<=items.length) return items[n-1];
      return null;
    }
    function resolveNoteRef(ref, currentList){
      if (!ref) return null;
      const byId = notes.find(n=>n.id === ref);
      if (byId) return byId;
      const n = parseInt(ref,10);
      if (!isNaN(n) && currentList && n>=1 && n<=currentList.length) return currentList[n-1];
      if (!isNaN(n) && n>=1 && n<=notes.length) return notes[n-1];
      return null;
    }

    /************
     * COMMANDS
     ************/
    const cmd = {};
    cmd.help = () => {
      println('General:');
      println('  SYNTAX <command>          show command syntax');
      println('');
      println('Tasks:');
      println('  ADD <text>                add a new item');
      println('  LIST [all|open|done|@tag] [--sort=due|pri] list items');
      println('  SHOW <id|#>               show a task with attached notes');
      println('  DONE <id|#>               mark done');
      println('  UNDONE <id|#>             unmark done');
      println('  DELETE <id|#>             delete item');
      println('  EDIT <id|#> <text>        edit text');
      println('  MOVE <id|#> <up|down|n>   reorder item');
      println('  TAG <id|#> +foo -bar      add/remove tags');
      println('  DUE <id|#> <YYYY-MM-DD>   set due date (or "clear")');
      println('  PRIORITY <id|#> <H|M|L>   set priority');
      println('  SEARCH <query>            find text in items');
      println('  RECUR <id|#> <n> <unit>  schedule recurring reminder');
      println('  SNOOZE <id|#> <YYYY-MM-DD> snooze reminder');
      println('  AQUERY <query>            advanced task query (tag/due/done/pri)');
      println('Notes:');
      println('  NOTE <title>|<desc>|[link]|[body] add a note');
      println('  NOTES [all|@tag|task:<ref>] list notes');
      println('  NEDIT <id|#> <title>|<desc>|[link]|[body] edit a note');
      println('  NRICH <id|#> <title>|[body]|[link]|[attachments] rich edit a note');
      println('  NDELETE <id|#>            delete a note');
      println('  NLINK <note|#> <task|#>   link a note to a task');
      println('  NUNLINK <note|#>          unlink note from task');
      println('  READNOTE <id|#>          show note details');
      println('  NSEARCH <query>           find text in notes');
      println('Security & Data:');
      println('  STATS                     summary counts');
      println('  CLEAR                     clear the display');
      println('  EXPORT                    download JSON (tasks + notes)');
      println('  IMPORT                    paste JSON to replace all data');
      println('  WIPE                      clear all data (with confirm)');
      println('  SETPASS                   set or clear passcode');
      println('  LOCK                      clear decrypted data from memory');
      println('  UNLOCK                    restore data with passcode');
      println('Appearance:');
      println('  THEME <bg> <fg> <border>   set colors');
      println('  THEMEPRESET <json>        apply theme preset');
      println('  THEMEEXPORT [name]        export current theme');
      println('  GDRIVECONFIG <client_id> <api_key>  set Google Drive credentials');
      println('  BACKUP [provider] [upload|download] sync data');
      println('  COLLAB <session>          start collaboration channel');
    };

    let lastTaskListCache = null;
    cmd.add = (args)=>{
      const text = args.join(' ').trim();
      if (!text){ println('usage: ADD <text>', 'error'); return; }
      const t = { id: makeId(), text, done:false, tags:[], due:null, pri:null, createdAt: Date.now(), doneAt:null };
      items.push(t); saveItems(items);
      println('added.', 'ok'); printTask(t);
    };
    cmd.list = (args)=>{
      let filter = 'open';
      let sortBy = null;
      if (args[0] && !args[0].startsWith('--')) filter = args[0];
      const sortArg = args.find(a=>a.startsWith('--sort='));
      if (sortArg) sortBy = sortArg.slice(7);
      lastTaskListCache = listFilteredTasks(filter, sortBy);
      let title = 'LIST ' + filter.toUpperCase();
      if (sortBy) title += ' SORTED BY ' + sortBy.toUpperCase();
      printList(lastTaskListCache, title);
    };
    cmd.show = (args)=>{
      const ref = args[0];
      const t = resolveTaskRef(ref, lastTaskListCache);
      if (!t) return println('not found', 'error');
      printTask(t);
      const attached = notes.filter(n=>n.taskId === t.id);
      if (attached.length){
        println('‚Äî notes ‚Äî', 'muted');
        attached.forEach((n,i)=>printNote(n,i+1));
      }else{
        println('‚Äî no notes ‚Äî', 'muted');
      }
    };
    cmd.done = (args)=>{
      const t = resolveTaskRef(args[0], lastTaskListCache);
      if (!t) return println('not found', 'error');
      t.done = true; t.doneAt = Date.now(); saveItems(items);
      println('marked done.', 'ok'); printTask(t);
    };
    cmd.undone = (args)=>{
      const t = resolveTaskRef(args[0], lastTaskListCache);
      if (!t) return println('not found', 'error');
      t.done = false; t.doneAt = null; saveItems(items);
      println('marked undone.', 'ok'); printTask(t);
    };
    cmd.delete = (args)=>{
      const t = resolveTaskRef(args[0], lastTaskListCache);
      if (!t) return println('not found', 'error');
      notes.forEach(n=>{ if (n.taskId === t.id) n.taskId = null; });
      if (dueTimers.has(t.id)){
        clearTimeout(dueTimers.get(t.id));
        dueTimers.delete(t.id);
      }
      items = items.filter(x=>x.id!==t.id); saveItems(items); saveNotes(notes);
      println('deleted.', 'ok');
    };
    cmd.edit = (args)=>{
      const ref = args.shift();
      const t = resolveTaskRef(ref, lastTaskListCache);
      if (!t) return println('not found', 'error');
      const text = args.join(' ').trim();
      if (!text) return println('usage: EDIT <id|#> <text>', 'error');
      t.text = text; saveItems(items);
      println('edited.', 'ok'); printTask(t);
    };
    cmd.move = (args)=>{
      const ref = args[0]; const how = args[1];
      const t = resolveTaskRef(ref, lastTaskListCache);
      if (!t) return println('not found', 'error');
      const idx = items.findIndex(x=>x.id===t.id);
      if (how === 'up' && idx>0){
        [items[idx-1], items[idx]] = [items[idx], items[idx-1]];
      } else if (how === 'down' && idx < items.length-1){
        [items[idx+1], items[idx]] = [items[idx], items[idx+1]];
      } else if (/^\d+$/.test(how)){
        let n = Math.max(0, Math.min(items.length-1, parseInt(how,10)-1));
        items.splice(idx,1);
        items.splice(n,0,t);
      } else {
        return println('usage: MOVE <id|#> <up|down|position#>', 'error');
      }
      saveItems(items);
      println('moved.', 'ok');
    };
    cmd.tag = (args)=>{
      const ref = args.shift();
      const t = resolveTaskRef(ref, lastTaskListCache);
      if (!t) return println('not found', 'error');
      t.tags = t.tags || [];
      for (const tok of args){
        if (tok.startsWith('+')){
          const tag = tok.slice(1);
          if (!t.tags.includes(tag)) t.tags.push(tag);
        } else if (tok.startsWith('-')){
          const tag = tok.slice(1);
          t.tags = t.tags.filter(x=>x!==tag);
        }
      }
      saveItems(items);
      println('tags updated.', 'ok'); printTask(t);
    };
    cmd.due = (args)=>{
      const ref = args.shift();
      const t = resolveTaskRef(ref, lastTaskListCache);
      if (!t) return println('not found', 'error');
      const val = (args[0]||'').toLowerCase();
      if (!val) return println('usage: DUE <id|#> <YYYY-MM-DD|clear>', 'error');
      if (val==='clear'){ t.due = null; }
      else { t.due = val; }
      saveItems(items);
      scheduleTaskNotification(t);
      println('due updated.', 'ok'); printTask(t);
    };
    cmd.priority = (args)=>{
      const ref = args.shift();
      const t = resolveTaskRef(ref, lastTaskListCache);
      if (!t) return println('not found', 'error');
      const p = (args[0]||'').toUpperCase();
      if (!['H','M','L'].includes(p)) return println('usage: PRIORITY <id|#> <H|M|L>', 'error');
      t.pri = p; saveItems(items);
      println('priority updated.', 'ok'); printTask(t);
    };
    cmd.search = (args)=>{
      const q = args.join(' ').toLowerCase();
      if (!q) return println('usage: SEARCH <query>', 'error');
      const hits = items.filter(t=> (t.text||'').toLowerCase().includes(q));
      printList(hits, 'SEARCH TASKS: ' + q);
    };

    cmd.recur = (args)=>{
      const ref = args[0];
      const every = parseInt(args[1], 10);
      const unit = args[2];
      const t = resolveTaskRef(ref, lastTaskListCache);
      if (!t || !every || !unit){
        return println('usage: RECUR <id|#> <n> <minute|hour|day|week>', 'error');
      }
      TerminalListFeatures.scheduleRecurringReminder(t.id, { every, unit });
      println('recurrence scheduled.', 'ok');
    };

    cmd.snooze = (args)=>{
      const t = resolveTaskRef(args[0], lastTaskListCache);
      const until = args[1];
      if (!t || !until){
        return println('usage: SNOOZE <id|#> <YYYY-MM-DD>', 'error');
      }
      TerminalListFeatures.snoozeReminder(t.id, until);
      println('snoozed.', 'ok');
      printTask(t);
    };

    cmd.aquery = (args)=>{
      const q = args.join(' ');
      if (!q) return println('usage: AQUERY <query>', 'error');
      const ids = TerminalListFeatures.parseAdvancedQuery(q);
      const hits = items.filter(t=> ids.includes(t.id));
      printList(hits, 'ADV QUERY: ' + q);
    };

    // Notes
    let lastNoteListCache = null;
    cmd.note = (args)=>{
      const parts = args.join(' ').split('|').map(s=>s.trim());
      const [title, description, link='', body=''] = parts;
      if (!title || !description) return println('usage: NOTE <title>|<description>|[link]|[body]', 'error');
      const n = { id: makeId(), title, description, link, body, tags:[], taskId: null, createdAt: Date.now(), updatedAt: Date.now() };
      notes.push(n); saveNotes(notes);
      println('note added.', 'ok'); printNote(n);
    };
    cmd.notes = (args)=>{
      const filter = args[0] || 'all';
      lastNoteListCache = listFilteredNotes(filter);
      printNotes(lastNoteListCache, 'NOTES ' + filter.toUpperCase());
    };
    cmd.nedit = (args)=>{
      const ref = args.shift();
      const n = resolveNoteRef(ref, lastNoteListCache);
      if (!n) return println('not found', 'error');
      const parts = args.join(' ').split('|').map(s=>s.trim());
      const [title, description, link='', body=''] = parts;
      if (!title || !description) return println('usage: NEDIT <id|#> <title>|<description>|[link]|[body]', 'error');
      n.title = title; n.description = description; n.link = link; n.body = body; n.updatedAt = Date.now(); saveNotes(notes);
      println('note edited.', 'ok'); printNote(n);
    };

    cmd.nrich = (args)=>{
      const ref = args.shift();
      const n = resolveNoteRef(ref, lastNoteListCache);
      if (!n) return println('not found', 'error');
      const parts = args.join(' ').split('|').map(s=>s.trim());
      const [title, body, link, attach] = parts;
      TerminalListFeatures.editNoteRich(n.id, {
        title: title || n.title,
        body: body || n.body,
        links: link ? [link] : (n.links || []),
        attachments: attach ? attach.split(',').map(s=>s.trim()).filter(Boolean) : (n.attachments || [])
      });
      println('note updated.', 'ok'); printNote(n);
    };
    cmd.ndelete = (args)=>{
      const ref = args[0];
      const n = resolveNoteRef(ref, lastNoteListCache);
      if (!n) return println('not found', 'error');
      notes = notes.filter(x=>x.id!==n.id); saveNotes(notes);
      println('note deleted.', 'ok');
    };
    cmd.nlink = (args)=>{
      const noteRef = args[0];
      const taskRef = args[1];
      if (!noteRef || !taskRef) return println('usage: NLINK <note|#> <task|#>', 'error');
      const n = resolveNoteRef(noteRef, lastNoteListCache);
      const t = resolveTaskRef(taskRef, lastTaskListCache);
      if (!n || !t) return println('not found', 'error');
      n.taskId = t.id; n.updatedAt = Date.now(); saveNotes(notes);
      println('note linked.', 'ok'); printNote(n);
    };
    cmd.nunlink = (args)=>{
      const noteRef = args[0];
      const n = resolveNoteRef(noteRef, lastNoteListCache);
      if (!n) return println('not found', 'error');
      n.taskId = null; n.updatedAt = Date.now(); saveNotes(notes);
      println('note unlinked.', 'ok'); printNote(n);
    };
    cmd.nsearch = (args)=>{
      const q = args.join(' ').toLowerCase();
      if (!q) return println('usage: NSEARCH <query>', 'error');
      const hits = notes.filter(n=> [n.title, n.description, n.link, n.body || n.text].some(f => (f||'').toLowerCase().includes(q)));
      printNotes(hits, 'SEARCH NOTES: ' + q);
    };

    cmd.readnote = (args)=>{
      const ref = args[0];
      const n = resolveNoteRef(ref, lastNoteListCache);
      if (!n) return println('not found', 'error');
      println('(' + n.id + ')');
      println('Title: ' + (n.title || ''));
      println('Description: ' + (n.description || ''));
      println('Link: ' + (n.link || ''));
      println('Body: ' + (n.body || n.text || ''));
      const atts = (n.attachments || []).join(', ');
      println('Attachments: ' + (atts || ''));
      const tags = (n.tags||[]).map(t=>'@'+t).join(' ');
      println('Tags: ' + tags);
      println('Linked Task: ' + (n.taskId || ''));
    };

    // General
    cmd.syntax = (args)=>{
      const topic = (args[0] || '').toLowerCase();
      const info = {
        nrich: [
          'NRICH <id|#> <title>|[body]|[link]|[attachments]',
          '  Rich edit a note; fields separated by "|".',
          '  title        new title (optional)',
          '  body         note body (optional)',
          '  link         URL or note:<id> (optional)',
          '  attachments  comma-separated URLs or data URIs (optional)'
        ],
        note: [
          'NOTE <title>|<desc>|[link]|[body]',
          '  Create a note; fields separated by "|".',
          '  link and body are optional.',
          '  Use NRICH to add attachments later.'
        ]
      };
      if (!topic || !info[topic]) {
        println('usage: SYNTAX <command>', 'muted');
        println('available: ' + Object.keys(info).map(k=>k.toUpperCase()).join(', '), 'muted');
        return;
      }
      info[topic].forEach(line => println(line));
    };
    cmd.clear = ()=>{
      output.innerHTML = '';
      lastTaskListCache = null;
      lastNoteListCache = null;
    };
    cmd.stats = ()=>{
      const total = items.length;
      const done = items.filter(t=>t.done).length;
      const open = total - done;
      const noteCount = notes.length;
      println(`Tasks ‚Äî Total: ${total}  Open: ${open}  Done: ${done}`);
      println(`Notes ‚Äî Total: ${noteCount}`);
    };
    cmd.theme = (args)=>{
      if (args.length !== 3){
        println('usage: THEME <bg> <fg> <border>', 'error');
        return;
      }
      const [bg, fg, border] = args;
      applyTheme({ bg, fg, border });
      saveTheme({ bg, fg, border });
      println('theme updated.', 'ok');
    };

    cmd.themepreset = (args)=>{
      const json = args.join(' ');
      if (!json) return println('usage: THEMEPRESET <json>', 'error');
      try {
        const preset = JSON.parse(json);
        TerminalListFeatures.applyThemePreset(preset);
        println('theme preset applied.', 'ok');
      } catch(e){
        println('invalid preset', 'error');
      }
    };

    cmd.themeexport = (args)=>{
      const name = args[0] || 'theme';
      TerminalListFeatures.exportThemePreset(name);
      println('theme exported.', 'ok');
    };

    cmd.gdriveconfig = (args)=>{
      const clientId = args[0];
      const apiKey = args[1];
      if (!clientId || !apiKey){
        println('usage: GDRIVECONFIG <client_id> <api_key>', 'error');
        return;
      }
      localStorage.setItem('terminal-list-gdrive-client-id', clientId);
      localStorage.setItem('terminal-list-gdrive-api-key', apiKey);
      println('gdrive credentials saved.', 'ok');
    };

    cmd.backup = (args)=>{
      const provider = args[0] || 'local';
      const mode = args[1] || 'upload';
      TerminalListFeatures.syncWithCloud(provider, mode)
        .then(()=> println(mode === 'upload' ? 'backup uploaded.' : 'backup restored.', 'ok'))
        .catch(err => println('backup failed: ' + err, 'error'));
    };

    let collabSession = null;
    cmd.collab = (args)=>{
      const session = args[0];
      if (!session) return println('usage: COLLAB <session>', 'error');
      collabSession = TerminalListFeatures.startCollaboration(session);
      if (collabSession && collabSession.broadcast) collabSession.broadcast();
      println('collaboration started.', 'ok');
    };
    function download(filename, text) {
      const a = document.createElement('a');
      a.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(text));
      a.setAttribute('download', filename);
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
    cmd.export = ()=>{
      const payload = { version: 2, items, notes };
      const json = JSON.stringify(payload, null, 2);
      download('terminal-list-export.json', json);
      println('exported.', 'ok');
    };
    cmd.import = async ()=>{
      println('Paste JSON and press Enter. Type CANCEL to abort.', 'muted');
      const text = await getNextLine();
      if (text.trim().toLowerCase() === 'cancel'){ println('import canceled.','muted'); return; }
      try{
        const incoming = JSON.parse(text);
        if (Array.isArray(incoming)){
          items = incoming;
        } else if (incoming && Array.isArray(incoming.items) && Array.isArray(incoming.notes)){
          items = incoming.items;
          notes = incoming.notes.map(n=>({
            id: n.id,
            title: n.title || '',
            description: n.description || '',
            link: n.link || '',
            body: n.body || n.text || '',
            tags: n.tags || [],
            taskId: n.taskId || null,
            createdAt: n.createdAt,
            updatedAt: n.updatedAt,
          }));
        } else {
          throw new Error('invalid format');
        }
        saveItems(items); saveNotes(notes);
        println('imported.', 'ok');
      }catch(e){
        println('import failed: ' + e.message, 'error');
      }
    };
    cmd.wipe = ()=> openModal();

    cmd.setpass = async ()=>{
      if (locked){ println('unlock first', 'error'); return; }
      println('Enter new passcode (blank to disable):', 'muted');
      const pass = await getNextLine(true);
      if (!pass){
        passKey = null; passSalt = null;
        await saveState(state);
        println('passcode cleared.', 'ok');
        return;
      }
      const saltBytes = crypto.getRandomValues(new Uint8Array(16));
      passSalt = b64(saltBytes);
      passKey = await deriveKey(pass, saltBytes);
      await saveState(state);
      println('passcode set.', 'ok');
    };

    cmd.lock = ()=>{
      if (locked){ println('already locked','muted'); return; }
      if (!passSalt){ println('no passcode set','error'); return; }
      items = []; notes = [];
      state.items = items; state.notes = notes;
      passKey = null;
      locked = true;
      lastTaskListCache = null; lastNoteListCache = null;
      println('locked.', 'ok');
      setTimeout(() => location.reload(), 0);
    };

    cmd.unlock = async ()=>{
      if (!locked){ println('not locked','muted'); return; }
      const raw = localStorage.getItem(STORE_KEY_V2);
      if (!raw){ println('nothing to unlock','error'); return; }
      try{
        const obj = JSON.parse(raw);
        if (!obj.enc){ println('no passcode set','error'); return; }
        println('Enter passcode:', 'muted');
        const pass = await getNextLine(true);
        const saltBytes = b64ToBuf(obj.enc.salt);
        const key = await deriveKey(pass, saltBytes);
        const iv = b64ToBuf(obj.enc.iv);
        const data = b64ToBuf(obj.enc.data);
        const buf = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, data);
        const decoded = JSON.parse(dec.decode(new Uint8Array(buf)));
        if (decoded && Array.isArray(decoded.items) && Array.isArray(decoded.notes)){
          state = decoded;
          items = state.items;
          notes = state.notes;
          passKey = key;
          passSalt = obj.enc.salt;
          locked = false;
          println('unlocked.', 'ok');
        } else {
          throw new Error('bad data');
        }
      }catch(e){ println('unlock failed','error'); }
    };

    /************
     * COMMAND LOOP
     ************/
    function parseAndRun(raw){
      const line = raw.trim();
      if (!line) return;
      println('> ' + line);
      history.push(line);
      historyIndex = history.length;
      localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
      const parts = line.split(/\s+/);
      const name = parts.shift().toLowerCase();
      const args = parts;
      const fn = cmd[name];
      if (!fn){ println('unknown command. type HELP.', 'error'); return; }
      if (locked && !['unlock','help','clear'].includes(name)){
        println('data locked. type UNLOCK.', 'error');
        return;
      }
      Promise.resolve(fn(args)).catch(err=>println('error: '+err.message,'error'));
    }
    function getNextLine(mask = false){
      awaitingLine = true;
      if (mask) command.type = 'password';
      return new Promise(resolve => {
        function handler(e){
          if (e.key === 'Enter'){
            const val = command.value;
            println('> ' + (mask ? '*'.repeat(val.length) : val));
            command.value = '';
            command.type = 'text';
            command.removeEventListener('keydown', handler);
            awaitingLine = false;
            resolve(val);
          }
        }
        command.addEventListener('keydown', handler);
      });
    }
    command.addEventListener('keydown', (e)=>{
      if (!awaitingLine && (e.key === 'ArrowUp' || e.key === 'ArrowDown')){
        if (e.key === 'ArrowUp'){
          if (historyIndex > 0) historyIndex--;
        } else {
          if (historyIndex < history.length) historyIndex++;
        }
        command.value = history[historyIndex] || '';
        e.preventDefault();
        return;
      }
      if (e.key === 'Enter'){
        if (awaitingLine) return;
        const v = command.value;
        command.value='';
        parseAndRun(v);
      }
    });

    /************
     * MODAL
     ************/
    function openModal(){ modal.style.display='flex'; }
    function closeModal(){ modal.style.display='none'; }
    btnCancel.addEventListener('click', closeModal);
    btnOK.addEventListener('click', ()=>{
      items = []; notes = [];
      saveItems(items); saveNotes(notes);
      closeModal();
      println('All data wiped.','ok');
    });

    /************
     * PWA INSTALL FLOW
     ************/
    const installBtn = document.getElementById('installBtn');
    const installStatus = document.getElementById('installStatus');
    const installHelp = document.getElementById('install-help');
    const installClose = document.getElementById('install-close');
    let deferredPrompt = null;

    function setStatus(s){ if (installStatus) installStatus.textContent = s; }

    // Register SW and wait until it's controlling the page
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js')
        .then(() => navigator.serviceWorker.ready)
        .then((reg) => {
          swRegistration = reg;
          setStatus('Ready');
          requestNotificationPermission().finally(rescheduleAllNotifications);
        })
        .catch(err => setStatus('SW error'));
    } else {
      setStatus('No SW support');
    }

    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      installBtn.classList.add('enabled');
      installBtn.disabled = false;
      setStatus('Install ready');
    });

    installBtn.addEventListener('click', async () => {
      // Already installed?
      if (window.matchMedia('(display-mode: standalone)').matches) {
        setStatus('Already installed');
        return;
      }
      if (deferredPrompt) {
        installBtn.disabled = true;
        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;
        deferredPrompt = null;
        installBtn.disabled = false;
        installBtn.classList.remove('enabled');
        setStatus(outcome === 'accepted' ? 'Installed' : 'Dismissed');
      } else {
        // Fallback help (we cannot force install if browser doesn't expose the prompt)
        installHelp.style.display = 'flex';
      }
    });

    installClose.addEventListener('click', () => {
      installHelp.style.display = 'none';
    });

    window.addEventListener('appinstalled', () => {
      setStatus('Installed');
      deferredPrompt = null;
      installBtn.classList.remove('enabled');
    });

    /************
     * VIEWPORT PINNING
     ************/
    (function pinBottom(){
      const vv = window.visualViewport;
      if (!vv) return;
      function reposition(){
        const inputBar = document.getElementById('input-bar');
        const obscured = Math.max(0, (window.innerHeight - (vv.height + vv.offsetTop)));
        inputBar.style.transform = 'translateY(' + (-obscured) + 'px)';
        const inputH = inputBar.getBoundingClientRect().height;
        output.style.bottom = 'calc(' + inputH + 'px + env(safe-area-inset-bottom) + ' + obscured + 'px)';
      }
      vv.addEventListener('resize', reposition);
      vv.addEventListener('scroll', reposition);
      window.addEventListener('orientationchange', ()=>setTimeout(reposition, 50));
      window.addEventListener('resize', reposition);
      window.requestAnimationFrame(reposition);
    })();

    // Initial greeting
    if (!localStorage.getItem('terminal-list-initialized-v4')){
      println('Welcome to Terminal List.');
      println('Type HELP for tasks & notes commands.');
      localStorage.setItem('terminal-list-initialized-v4','1');
    }
    if (locked) println('Data is locked. Type UNLOCK to access.', 'muted');

    // Focus on output tap
    output.addEventListener('pointerdown', ()=>command.focus());
  </script>
</body>
</html>
