<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Terminal List PWA</title>
  <style>
    :root{
      --bg: #000;
      --fg: #32cd32; /* limegreen */
      --border: #32cd32;
      --font: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --header-h: 56px;
      --input-h: 52px;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: var(--font);
      overflow: hidden;
    }
    /* Old-school: left aligned, minimal */
    #header{
      position: fixed; top: 0; left: 0; right: 0;
      height: var(--header-h);
      padding: 6px 10px;
      border-bottom: 1px solid var(--border);
      background: var(--bg);
      z-index: 1000;
      line-height: 1.2;
      user-select: none;
    }
    #header .title{ font-weight: 600; }
    #header .subtitle{ opacity: 0.9; }
    #output{
      position: absolute;
      top: var(--header-h);
      left: 0; right: 0;
      bottom: calc(var(--input-h) + env(safe-area-inset-bottom));
      padding: 10px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      box-sizing: border-box;
    }
    #input-bar{
      position: fixed; left: 0; right: 0;
      height: var(--input-h);
      bottom: env(safe-area-inset-bottom);
      border-top: 1px solid var(--border);
      background: var(--bg);
      z-index: 1000;
      display: flex; align-items: center; gap: 8px;
      padding: 6px 10px; box-sizing: border-box;
      transform: translateY(0);
      will-change: transform;
    }
    #prompt-label{ user-select: none; white-space: pre; }
    #command{
      flex: 1; min-width: 0;
      background: transparent; color: var(--fg);
      border: 0; outline: none; caret-color: var(--fg);
      font-family: var(--font); font-size: 16px;
    }
    .line{ white-space: pre-wrap; word-break: break-word; }
    .muted{ opacity: 0.85; }
    .error{ color: #ff4d4d; } /* subtle red for errors */
    .ok{ color: #7fffd4; }  /* aquamarine for confirms */
    .task-done{ opacity: 0.7; text-decoration: line-through; }
    .task-id{ opacity: 0.9; }
    .tag{ opacity: 0.9; }
    .priH{ color: #ffb347; } /* high priority */
    .priM{ color: #87cefa; } /* medium */
    .priL{ opacity: 0.95; }  /* low */
    /* WIPE modal */
    #modal{
      position: fixed; inset: 0; display: none;
      align-items: center; justify-content: center;
      background: rgba(0,0,0,0.92);
      z-index: 2000;
    }
    #modal .card{
      border: 1px solid var(--border);
      padding: 16px 20px;
      width: min(520px, calc(100% - 40px));
      background: #000;
      box-sizing: border-box;
    }
    .row{ display:flex; gap:10px; margin-top:14px; justify-content:flex-end; }
    button.terminal{
      background: transparent; color: var(--fg);
      border: 1px solid var(--border);
      padding: 8px 14px; font-family: var(--font);
      cursor: pointer;
    }
    button.terminal:hover{ outline: 1px dashed var(--border); }
  </style>
</head>
<body>
  <div id="header">
    <div class="title">TERMINAL LIST PWA</div>
    <div class="subtitle">Type help to begin</div>
  </div>

  <div id="output" role="log" aria-live="polite"></div>

  <div id="input-bar" role="group" aria-label="Command input">
    <span id="prompt-label">&gt; </span>
    <input id="command" type="text" inputmode="text" autocapitalize="none"
           autocomplete="off" spellcheck="false" placeholder="enter command..." />
  </div>

  <div id="modal" role="dialog" aria-modal="true" aria-labelledby="wipe-title">
    <div class="card">
      <div id="wipe-title" class="line">Confirm WIPE</div>
      <div class="line" style="margin-top:6px">Are you sure you want to WIPE all data?</div>
      <div class="row">
        <button class="terminal" id="btn-cancel">Cancel</button>
        <button class="terminal" id="btn-confirm">WIPE</button>
      </div>
    </div>
  </div>

  <script>
    // ===== Storage =====
    const STORE_KEY = 'terminal-list-items-v1';
    function loadItems(){
      try{ return JSON.parse(localStorage.getItem(STORE_KEY)) || []; }
      catch{ return []; }
    }
    function saveItems(items){
      localStorage.setItem(STORE_KEY, JSON.stringify(items));
    }
    function makeId(){ return Math.random().toString(36).slice(2,8); }

    // ===== State =====
    let items = loadItems(); // [{id,text,done,tags[],due,pri,createdAt,doneAt}]
    const output = document.getElementById('output');
    const command = document.getElementById('command');
    const inputBar = document.getElementById('input-bar');
    const modal = document.getElementById('modal');
    const btnCancel = document.getElementById('btn-cancel');
    const btnOK = document.getElementById('btn-confirm');

    // ===== UI helpers =====
    function println(text, cls){
      const div = document.createElement('div');
      div.className = 'line' + (cls ? ' ' + cls : '');
      div.textContent = text;
      output.appendChild(div);
      output.scrollTop = output.scrollHeight;
    }
    function printTask(t, indexShown){
      // e.g., [3] (ab12cd) ☐ Build PWA @work ^2025-09-01 !H
      const box = t.done ? '☑' : '☐';
      const pri = t.pri === 'H' ? ' !H' : t.pri === 'M' ? ' !M' : t.pri === 'L' ? ' !L' : '';
      const tags = (t.tags||[]).map(s=>' @'+s).join('');
      const due = t.due ? ' ^' + t.due : '';
      const idTxt = t.id;
      const idx = typeof indexShown === 'number' ? '['+indexShown+'] ' : '';
      const line = idx + '(' + idTxt + ') ' + box + ' ' + t.text + tags + due + pri;
      const div = document.createElement('div');
      div.className = 'line' + (t.done ? ' task-done' : '');
      div.textContent = line;
      output.appendChild(div);
    }
    function printList(arr, title){
      if (title) println(title, 'muted');
      if (!arr.length){ println('— no items —', 'muted'); return; }
      arr.forEach((t,i)=>printTask(t,i+1));
      output.scrollTop = output.scrollHeight;
    }

    // ===== Commands =====
    const cmd = {};
    cmd.help = () => {
      println('Commands:');
      println('  ADD <text>                add a new item');
      println('  LIST [all|open|done|@tag] list items');
      println('  DONE <id|#>               mark done');
      println('  UNDONE <id|#>             unmark done');
      println('  DELETE <id|#>             delete item');
      println('  EDIT <id|#> <text>        edit text');
      println('  MOVE <id|#> <up|down|n>   reorder item');
      println('  TAG <id|#> +foo -bar      add/remove tags');
      println('  DUE <id|#> <YYYY-MM-DD>   set due date (or "clear")');
      println('  PRIORITY <id|#> <H|M|L>   set priority');
      println('  SEARCH <query>            find text in items');
      println('  STATS                     summary counts');
      println('  EXPORT                    download JSON');
      println('  IMPORT                    paste JSON to import');
      println('  WIPE                      clear all (with confirm)');
    };

    function resolveRef(ref){
      // ref can be id or visible index (# starting from 1 for current LIST order)
      // We'll try id first, then numeric index against current items order (default: by createdAt).
      if (!ref) return null;
      const byId = items.find(t=>t.id === ref);
      if (byId) return byId;
      const n = parseInt(ref,10);
      if (!isNaN(n) && n>=1 && n<=items.length) return items[n-1];
      return null;
    }

    cmd.add = (args)=>{
      const text = args.join(' ').trim();
      if (!text){ println('usage: ADD <text>', 'error'); return; }
      const t = { id: makeId(), text, done:false, tags:[], due:null, pri:null, createdAt: Date.now(), doneAt:null };
      items.push(t); saveItems(items);
      println('added.', 'ok');
      printTask(t);
    };

    function listFiltered(filter){
      let arr = [...items];
      // default sort by createdAt
      arr.sort((a,b)=>a.createdAt - b.createdAt);
      if (!filter || filter==='open') arr = arr.filter(t=>!t.done);
      else if (filter==='done') arr = arr.filter(t=>t.done);
      else if (filter==='all') { /* no-op */ }
      else if (filter.startsWith('@')) {
        const tag = filter.slice(1).toLowerCase();
        arr = arr.filter(t=>(t.tags||[]).map(s=>s.toLowerCase()).includes(tag));
      }
      return arr;
    }

    cmd.list = (args)=>{
      const filter = args[0] || 'open';
      const arr = listFiltered(filter);
      printList(arr, 'LIST ' + filter.toUpperCase());
    };

    function findByRefOrIndex(ref, currentList){
      if (!ref){ println('missing id or #', 'error'); return null; }
      // Allow # by the most recent LIST filter: if provided, pass the currentList from the caller.
      // If not provided, fallback to overall items order.
      if (currentList && /^\d+$/.test(ref)){
        const n = parseInt(ref,10);
        if (n>=1 && n<=currentList.length) return currentList[n-1];
      }
      // Try global resolution
      return resolveRef(ref);
    }

    cmd.done = (args, ctx)=>{
      const ref = args[0];
      const t = findByRefOrIndex(ref, ctx?.lastList);
      if (!t) return println('not found', 'error');
      t.done = true; t.doneAt = Date.now(); saveItems(items);
      println('marked done.', 'ok');
      printTask(t);
    };

    cmd.undone = (args, ctx)=>{
      const ref = args[0];
      const t = findByRefOrIndex(ref, ctx?.lastList);
      if (!t) return println('not found', 'error');
      t.done = false; t.doneAt = null; saveItems(items);
      println('marked undone.', 'ok');
      printTask(t);
    };

    cmd.delete = (args, ctx)=>{
      const ref = args[0];
      const t = findByRefOrIndex(ref, ctx?.lastList);
      if (!t) return println('not found', 'error');
      items = items.filter(x=>x.id!==t.id); saveItems(items);
      println('deleted.', 'ok');
    };

    cmd.edit = (args, ctx)=>{
      const ref = args.shift();
      const t = findByRefOrIndex(ref, ctx?.lastList);
      if (!t) return println('not found', 'error');
      const text = args.join(' ').trim();
      if (!text) return println('usage: EDIT <id|#> <text>', 'error');
      t.text = text; saveItems(items);
      println('edited.', 'ok'); printTask(t);
    };

    cmd.move = (args, ctx)=>{
      const ref = args[0];
      const how = args[1];
      const t = findByRefOrIndex(ref, ctx?.lastList);
      if (!t) return println('not found', 'error');
      const idx = items.findIndex(x=>x.id===t.id);
      if (how === 'up' && idx>0){
        [items[idx-1], items[idx]] = [items[idx], items[idx-1]];
      } else if (how === 'down' && idx < items.length-1){
        [items[idx+1], items[idx]] = [items[idx], items[idx+1]];
      } else if (/^\d+$/.test(how)){
        let n = parseInt(how,10)-1;
        n = Math.max(0, Math.min(items.length-1, n));
        items.splice(idx,1);
        items.splice(n,0,t);
      } else {
        return println('usage: MOVE <id|#> <up|down|position#>', 'error');
      }
      saveItems(items);
      println('moved.', 'ok');
    };

    cmd.tag = (args, ctx)=>{
      const ref = args.shift();
      const t = findByRefOrIndex(ref, ctx?.lastList);
      if (!t) return println('not found', 'error');
      t.tags = t.tags || [];
      for (const tok of args){
        if (tok.startsWith('+')){
          const tag = tok.slice(1);
          if (!t.tags.includes(tag)) t.tags.push(tag);
        } else if (tok.startsWith('-')){
          const tag = tok.slice(1);
          t.tags = t.tags.filter(x=>x!==tag);
        }
      }
      saveItems(items);
      println('tags updated.', 'ok'); printTask(t);
    };

    cmd.due = (args, ctx)=>{
      const ref = args.shift();
      const t = findByRefOrIndex(ref, ctx?.lastList);
      if (!t) return println('not found', 'error');
      const val = (args[0]||'').toLowerCase();
      if (!val) return println('usage: DUE <id|#> <YYYY-MM-DD|clear>', 'error');
      if (val==='clear'){ t.due = null; }
      else { t.due = val; }
      saveItems(items);
      println('due updated.', 'ok'); printTask(t);
    };

    cmd.priority = (args, ctx)=>{
      const ref = args.shift();
      const t = findByRefOrIndex(ref, ctx?.lastList);
      if (!t) return println('not found', 'error');
      const p = (args[0]||'').toUpperCase();
      if (!['H','M','L'].includes(p)) return println('usage: PRIORITY <id|#> <H|M|L>', 'error');
      t.pri = p; saveItems(items);
      println('priority updated.', 'ok'); printTask(t);
    };

    cmd.search = (args)=>{
      const q = args.join(' ').toLowerCase();
      if (!q) return println('usage: SEARCH <query>', 'error');
      const hits = items.filter(t=> (t.text||'').toLowerCase().includes(q));
      printList(hits, 'SEARCH: ' + q);
    };

    cmd.stats = ()=>{
      const total = items.length;
      const done = items.filter(t=>t.done).length;
      const open = total - done;
      println(`Total: ${total}  Open: ${open}  Done: ${done}`);
    };

    // EXPORT / IMPORT
    function download(filename, text) {
      const a = document.createElement('a');
      a.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(text));
      a.setAttribute('download', filename);
      document.body.appendChild(a);
      a.click();
      a.remove();
    }
    cmd.export = ()=>{
      const json = JSON.stringify(items, null, 2);
      download('terminal-list-export.json', json);
      println('exported.', 'ok');
    };
    cmd.import = async ()=>{
      println('Paste JSON and press Enter. Type CANCEL to abort.', 'muted');
      // Temporarily capture next line as JSON
      const text = await getNextLine();
      if (text.trim().toLowerCase() === 'cancel'){ println('import canceled.','muted'); return; }
      try{
        const incoming = JSON.parse(text);
        if (!Array.isArray(incoming)) throw new Error('invalid format');
        items = incoming; saveItems(items);
        println('imported.', 'ok');
      }catch(e){
        println('import failed: ' + e.message, 'error');
      }
    };

    cmd.wipe = ()=> openModal();

    // ===== Command loop =====
    let lastListCache = null; // store last LIST result for # indexing
    function parseAndRun(raw){
      const line = raw.trim();
      if (!line) return;
      println('> ' + line);
      const parts = line.split(/\s+/);
      const name = parts.shift().toLowerCase();
      const args = parts;
      const ctx = {};
      // if user just ran LIST, seed ctx.lastList for # addressing
      if (name === 'list'){
        lastListCache = listFiltered(args[0] || 'open');
      } else {
        ctx.lastList = lastListCache;
      }
      const fn = cmd[name];
      if (!fn){ println('unknown command. type HELP.', 'error'); return; }
      Promise.resolve(fn(args, ctx)).catch(err=>println('error: '+err.message,'error'));
    }

    // Helper to capture next line for IMPORT
    function getNextLine(){
      return new Promise(resolve => {
        function handler(e){
          if (e.key === 'Enter'){
            const val = command.value;
            println('> ' + val);
            command.value = '';
            command.removeEventListener('keydown', handler);
            resolve(val);
          }
        }
        command.addEventListener('keydown', handler);
      });
    }

    command.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter'){
        const v = command.value;
        command.value='';
        parseAndRun(v);
      }
    });

    // ===== Modal controls =====
    function openModal(){ modal.style.display='flex'; }
    function closeModal(){ modal.style.display='none'; }
    btnCancel.addEventListener('click', closeModal);
    btnOK.addEventListener('click', ()=>{
      items = []; saveItems(items);
      closeModal();
      println('All data wiped.','ok');
    });

    // ===== VisualViewport pinning for mobile keyboard =====
    (function pinBottom(){
      const vv = window.visualViewport;
      if (!vv) return;
      function reposition(){
        const obscured = Math.max(0, (window.innerHeight - (vv.height + vv.offsetTop)));
        inputBar.style.transform = 'translateY(' + (-obscured) + 'px)';
        const inputH = inputBar.getBoundingClientRect().height;
        output.style.bottom = 'calc(' + inputH + 'px + env(safe-area-inset-bottom) + ' + obscured + 'px)';
      }
      vv.addEventListener('resize', reposition);
      vv.addEventListener('scroll', reposition);
      window.addEventListener('orientationchange', ()=>setTimeout(reposition, 50));
      window.addEventListener('resize', reposition);
      window.requestAnimationFrame(reposition);
    })();

    // Focus on tap anywhere
    output.addEventListener('pointerdown', ()=>command.focus());

    // Initial greeting (only first run)
    if (!localStorage.getItem('terminal-list-initialized')){
      println('Welcome to Terminal List.');
      println('Type HELP for commands.');
      localStorage.setItem('terminal-list-initialized','1');
    }
  </script>
</body>
</html>
