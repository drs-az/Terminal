<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Terminal List</title>
  <meta name="theme-color" content="#0b0d0e"/>
  <link rel="manifest" href="manifest.webmanifest">
  <style>
    :root {
      --bg: #0b0d0e;
      --panel: #0f1214;
      --fg: #c7f7d4;
      --muted: #7bdba9;
      --accent: #00d084;
      --danger: #ff4d4f;
      --warning: #ffd166;
      --ok: #00e676;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Fira Code", monospace;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: var(--mono);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    *, *::before, *::after { box-sizing: border-box; }
    html, body { height: 100%; width: 100%; overflow-x: hidden; }
    body { max-width: 100vw; }
    .wrap { min-height: 100svh; max-width: 100%; overflow-x: hidden; }
    #console { overflow-y: auto; overflow-x: hidden; word-break: break-word; overflow-wrap: anywhere; }
    .line { overflow-wrap: anywhere; word-break: break-word; }
    header, .input-bar { max-width: 100%; overflow-x: hidden; }
    .input-bar { flex-wrap: nowrap; }
    button { max-width: 100%; white-space: nowrap; }
    .wrap {
      height: 100%;
      display: grid;
      grid-template-rows: auto 1fr auto;
    }
    header {
      padding: 10px 14px;
      background: linear-gradient(180deg, #0d1113, #0a0c0d);
      border-bottom: 1px solid #122016;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .brand {
      letter-spacing: 0.4px;
      font-weight: 700;
      color: var(--muted);
    }
    .status-dot {
      width: 10px; height: 10px; border-radius: 50%;
      background: var(--ok);
      box-shadow: 0 0 10px var(--ok);
      margin-left: auto;
    }
    #console {
      padding: 16px;
      overflow: auto;
      white-space: pre-wrap;
      line-height: 1.4;
      caret-color: var(--accent);
    }
    .line { display: block; }
    .prompt { color: var(--muted); }
    .cmd { color: var(--fg); }
    .note { color: #9ad1ff; }
    .warn { color: var(--warning); }
    .err { color: var(--danger); }
    .ok { color: var(--ok); }
    .dim { opacity: .8; }
    .kbd { background: #14231a; border: 1px solid #183322; padding: 0 4px; border-radius: 4px; }
    .input-bar {
      display: flex;
      padding: 10px 14px;
      border-top: 1px solid #122016;
      background: #0c0f10;
      gap: 10px;
    }
    #input {
      flex: 1;
      background: var(--panel);
      border: 1px solid #15361f;
      color: var(--fg);
      font-family: var(--mono);
      padding: 10px 12px;
      border-radius: 8px;
      outline: none;
    }
    #input::placeholder { color: #6dbf93; }
    button {
      background: #13241a;
      color: var(--muted);
      border: 1px solid #1b3f2a;
      padding: 8px 10px;
      border-radius: 8px;
      font-family: var(--mono);
      cursor: pointer;
    }
    button:hover { filter: brightness(1.2); }
    .lockscreen {
      position: fixed; inset: 0;
      display: none;
      align-items: center; justify-content: center;
      background: rgba(6,8,9,.92);
      backdrop-filter: blur(3px);
      z-index: 10;
      padding: 20px;
    }
    .panel {
      width: min(520px, 92vw);
      background: #0e1213;
      border: 1px solid #173220;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,.5);
      padding: 18px;
    }
    .panel h2 { margin: 0 0 6px; color: var(--muted); }
    .field { margin: 8px 0; }
    .field input {
      width: 100%;
      background: var(--panel);
      border: 1px solid #15361f;
      color: var(--fg);
      font-family: var(--mono);
      padding: 10px 12px;
      border-radius: 8px;
      outline: none;
    }
    .row { display: flex; gap: 8px; align-items: center; }
    .right { margin-left: auto; }
    .tiny { font-size: 12px; color: #8ec9a7; }
    .hidden { display:none !important; }
    .badge { border: 1px solid #1d4a30; padding: 2px 6px; border-radius: 999px; color: #98e7be; margin-left: 6px; }
    a { color: #6ff3b7; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="brand">TERMINAL LIST<span class="badge">PWA</span></div>
      <div class="tiny">Type <span class="kbd">help</span> to begin</div>
      <div class="status-dot" id="statusDot" title="Unlocked"></div>
    </header>
    <main id="console" tabindex="0" aria-live="polite"></main>
    <div class="input-bar">
      <input id="input" placeholder="> enter command…" autocomplete="off" />
      <button id="btnHelp" title="Show help">help</button>
      <button id="btnExport" title="Export data">export</button>
      <button id="btnImport" title="Import data">import</button>
      <button id="btnLock" title="Lock">lock</button>
      <button id="btnWipe" title="Emergency wipe">wipe</button>
      <input type="file" id="fileInput" class="hidden" accept="application/json" />
    </div>
  </div>

  <!-- Lock Screen -->
  <div class="lockscreen" id="lockscreen" role="dialog" aria-modal="true">
    <div class="panel">
      <h2>TERMINAL LIST — LOCKED</h2>
      <div class="tiny">Enter passcode to unlock</div>
      <div class="field"><input id="passInput" type="password" placeholder="passcode" autocomplete="current-password"></div>
      <div class="row">
        <button id="btnUnlock">Unlock</button>
        <button id="btnCancel" class="right">Cancel</button>
      </div>
      <div id="lockMsg" class="tiny"></div>
    </div>
  </div>

  <script>
  // ---------------- PWA: Service Worker ----------------
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js').catch(console.error);
    });
  }

  // ---------------- Utilities ----------------
  const $ = sel => document.querySelector(sel);
  const consoleEl = $("#console");
  const inputEl = $("#input");
  const fileEl = $("#fileInput");
  const statusDot = $("#statusDot");
  const lockUI = $("#lockscreen");
  const passInput = $("#passInput");
  const lockMsg = $("#lockMsg");

  const APP_KEY = "terminal-list-v1";
  const VERSION = 1;
  const KDF_ITER = 200000; // strong but still snappy
  const encoder = new TextEncoder();
  const decoder = new TextDecoder();
  let memKey = null; // CryptoKey when unlocked
  let state = null;

  function uuid() {
    return crypto.randomUUID ? crypto.randomUUID() :
      'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
        const r = crypto.getRandomValues(new Uint8Array(1))[0] & 15;
        const v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
      });
  }

  function nowISO(){ return new Date().toISOString(); }

  function print(html, cls="line") {
    const line = document.createElement('div');
    line.className = cls;
    line.innerHTML = html;
    consoleEl.appendChild(line);
    consoleEl.scrollTop = consoleEl.scrollHeight;
  }

  function printHeader() {
    print('<span class="prompt">$</span> <span class="cmd">Terminal List</span> <span class="dim">v'+VERSION+'</span>');
    print('<span class="dim">Type <span class="kbd">help</span> for commands. Data is stored locally and can be exported/imported as JSON.</span>');
  }

  function tokenise(input) {
    // Handles quoted strings: "..." or '...'
    const re = /"([^"]*)"|'([^']*)'|\S+/g;
    const out = [];
    let m;
    while ((m = re.exec(input))) {
      out.push(m[1] ?? m[2] ?? m[0]);
    }
    return out;
  }

  function download(filename, text) {
    const blob = new Blob([text], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click();
    setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
  }

  // ---------------- Crypto (AES-GCM + PBKDF2) ----------------
  async function deriveKey(pass, saltB64) {
    const salt = saltB64 ? Uint8Array.from(atob(saltB64), c => c.charCodeAt(0)) : crypto.getRandomValues(new Uint8Array(16));
    const keyMaterial = await crypto.subtle.importKey('raw', encoder.encode(pass), 'PBKDF2', false, ['deriveKey']);
    const key = await crypto.subtle.deriveKey({
      name: 'PBKDF2',
      salt,
      iterations: KDF_ITER,
      hash: 'SHA-256'
    }, keyMaterial, { name: 'AES-GCM', length: 256 }, false, ['encrypt','decrypt']);
    return { key, saltB64: btoa(String.fromCharCode(...salt)) };
  }

  async function encryptState(key, obj) {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const plaintext = encoder.encode(JSON.stringify(obj));
    const ciphertext = new Uint8Array(await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, plaintext));
    return { iv: btoa(String.fromCharCode(...iv)), data: btoa(String.fromCharCode(...ciphertext)) };
  }

  async function decryptState(key, enc) {
    const iv = Uint8Array.from(atob(enc.iv), c => c.charCodeAt(0));
    const data = Uint8Array.from(atob(enc.data), c => c.charCodeAt(0));
    const plain = new Uint8Array(await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, data));
    return JSON.parse(decoder.decode(plain));
  }

  // ---------------- Storage ----------------
  function getRaw() {
    const raw = localStorage.getItem(APP_KEY);
    if (!raw) return null;
    try { return JSON.parse(raw); } catch { return null; }
  }

  async function save() {
    const prev = getRaw() || {};
    const wrapping = {
      version: VERSION,
      encrypted: !!memKey,
      kdf: prev.kdf || null,
      enc: null,
      state: null
    };
    if (memKey) {
      // ensure KDF salt persisted
      if (!prev.kdf) {
        // create from memKey context by deriving once to get a salt (we can't extract from key)
        const dummy = await deriveKey('salt-provision', null);
        wrapping.kdf = { salt: dummy.saltB64, iter: KDF_ITER };
      } else {
        wrapping.kdf = prev.kdf;
      }
      wrapping.enc = await encryptState(memKey, state);
    } else {
      wrapping.state = state;
    }
    localStorage.setItem(APP_KEY, JSON.stringify(wrapping));
  }

  async function load() {
    const raw = getRaw();
    if (!raw) {
      state = {
        created: nowISO(),
        notes: [],
        lists: [
          { id: uuid(), title: "Inbox", created: nowISO(), items: [] }
        ],
        settings: {}
      };
      memKey = null;
      await save();
      return true;
    }
    if (raw.encrypted) {
      // show lockscreen; wait for unlock
      lockUI.style.display = 'flex';
      statusDot.style.background = '#ff4d4f';
      statusDot.style.boxShadow = '0 0 8px #ff4d4f';
      return false;
    } else {
      state = raw.state;
      memKey = null;
      return true;
    }
  }

  async function attemptUnlock(pass) {
    const raw = getRaw();
    if (!raw || !raw.encrypted || !raw.kdf) throw new Error("No encrypted data");
    const { key } = await deriveKey(pass, raw.kdf.salt);
    try {
      state = await decryptState(key, raw.enc);
      memKey = key;
      await save(); // rewrap with same kdf
      lockUI.style.display = 'none';
      statusDot.style.background = '#00e676';
      statusDot.style.boxShadow = '0 0 8px #00e676';
      print('<span class="ok">Unlocked.</span>');
      if (consoleEl.childElementCount === 0) printHeader();
      return true;
    } catch (e) {
      throw new Error("Incorrect passcode");
    }
  }

  function lockNow() {
    memKey = null;
    const raw = getRaw();
    if (raw && raw.enc) {
      lockUI.style.display = 'flex';
      statusDot.style.background = '#ff4d4f';
      statusDot.style.boxShadow = '0 0 8px #ff4d4f';
      print('<span class="warn">Locked.</span>');
    } else {
      print('<span class="warn">No passcode set. Use <span class="kbd">setpass</span> to enable encryption.</span>');
    }
  }

  async function setPasscode(newPass) {
    if (!newPass || newPass.length < 4) { print('<span class="err">Passcode must be at least 4 characters.</span>'); return; }
    const { key, saltB64 } = await deriveKey(newPass, null);
    memKey = key;
    const raw = getRaw() || {};
    state.settings.pass_hint = state.settings.pass_hint || "";
    await save(); // saves encrypted with memKey and sets kdf if needed
    // overwrite kdf with actual salt used for this pass
    const wrap = getRaw();
    wrap.kdf = { salt: saltB64, iter: KDF_ITER };
    localStorage.setItem(APP_KEY, JSON.stringify(wrap));
    print('<span class="ok">Passcode set. Data encrypted at rest (AES‑256‑GCM).</span>');
    statusDot.style.background = '#00e676';
    statusDot.style.boxShadow = '0 0 8px #00e676';
  }

  // ---------------- Domain Ops ----------------
  function findList(idOrTitle) {
    return state.lists.find(l => l.id === idOrTitle || l.title.toLowerCase() === idOrTitle.toLowerCase());
  }
  function findNote(idOrTitle) {
    return state.notes.find(n => n.id === idOrTitle || n.title.toLowerCase() === idOrTitle.toLowerCase());
  }

  // ---------------- Command Handlers ----------------
  async function cmd_help() {
    print(`
<span class="note">Commands</span>
  <span class="kbd">help</span> — show this help
  <span class="kbd">notes</span> — list notes
  <span class="kbd">note "Title"</span> — create note
  <span class="kbd">open note &lt;id|title&gt;</span> — view note
  <span class="kbd">del note &lt;id|title&gt;</span> — delete note
  <span class="kbd">write note &lt;id|title&gt; "text"</span> — append to note

  <span class="kbd">lists</span> — list lists
  <span class="kbd">list "Title"</span> — create list
  <span class="kbd">add &lt;list&gt; "item"</span> — add list item
  <span class="kbd">done &lt;list&gt; &lt;itemId&gt;</span> — toggle done
  <span class="kbd">show &lt;list&gt;</span> — show list detail
  <span class="kbd">del list &lt;id|title&gt;</span> — delete list

  <span class="kbd">export</span> — download JSON
  <span class="kbd">import</span> — import JSON (merge)
  <span class="kbd">import replace</span> — replace all data

  <span class="kbd">setpass</span> — set/replace passcode
  <span class="kbd">lock</span> — lock app
  <span class="kbd">unlock</span> — unlock app
  <span class="kbd">wipe</span> — emergency data wipe
    `.trim());
  }

  async function cmd_notes() {
    if (!state.notes.length) { print('<span class="dim">No notes.</span>'); return; }
    state.notes.forEach(n => {
      print('📝  <b>'+n.title+'</b>  <span class="dim">('+n.id.slice(0,8)+')</span>');
    });
  }
  async function cmd_note(args) {
    const title = args.join(' ').trim().replace(/^["']|["']$/g,'');
    if (!title) { print('<span class="err">Usage: note "Title"</span>'); return; }
    const note = { id: uuid(), title, content: "", created: nowISO(), updated: nowISO() };
    state.notes.unshift(note);
    await save();
    print('<span class="ok">Created note:</span> '+note.title+' <span class="dim">('+note.id+')</span>');
  }
  async function cmd_open_note(target) {
    const n = findNote(target);
    if (!n) { print('<span class="err">Note not found.</span>'); return; }
    print('─── <b>'+n.title+'</b> <span class="dim">('+n.id+')</span> ───');
    print(n.content ? n.content : '<span class="dim">[empty]</span>');
  }
  async function cmd_write_note(target, text) {
    const n = findNote(target);
    if (!n) { print('<span class="err">Note not found.</span>'); return; }
    n.content += (n.content ? "\n" : "") + text;
    n.updated = nowISO();
    await save();
    print('<span class="ok">Appended to note.</span>');
  }
  async function cmd_del_note(target) {
    const i = state.notes.findIndex(x => x.id === target || x.title.toLowerCase() === target.toLowerCase());
    if (i === -1) { print('<span class="err">Note not found.</span>'); return; }
    const removed = state.notes.splice(i,1)[0];
    await save();
    print('<span class="ok">Deleted note:</span> '+removed.title);
  }

  async function cmd_lists() {
    state.lists.forEach(l => {
      const total = l.items.length;
      const done = l.items.filter(i=>i.done).length;
      print('📦  <b>'+l.title+'</b>  <span class="dim">('+l.id.slice(0,8)+')  '+done+'/'+total+' done</span>');
    });
  }
  async function cmd_list(args) {
    const title = args.join(' ').trim().replace(/^["']|["']$/g,'');
    if (!title) { print('<span class="err">Usage: list "Title"</span>'); return; }
    const list = { id: uuid(), title, created: nowISO(), items: [] };
    state.lists.unshift(list);
    await save();
    print('<span class="ok">Created list:</span> '+list.title+' <span class="dim">('+list.id+')</span>');
  }
  async function cmd_add(listRef, text) {
    const l = findList(listRef);
    if (!l) { print('<span class="err">List not found.</span>'); return; }
    const item = { id: uuid().slice(0,6), text, done: false, created: nowISO(), done_at: null };
    l.items.unshift(item);
    await save();
    print('<span class="ok">Added:</span> ['+item.id+'] '+item.text);
  }
  async function cmd_done(listRef, itemId) {
    const l = findList(listRef);
    if (!l) { print('<span class="err">List not found.</span>'); return; }
    const it = l.items.find(i => i.id === itemId);
    if (!it) { print('<span class="err">Item not found.</span>'); return; }
    it.done = !it.done;
    it.done_at = it.done ? nowISO() : null;
    await save();
    print('<span class="ok">Toggled:</span> ['+it.id+'] '+(it.done ? '✓ done' : '◻︎ not done'));
  }
  async function cmd_show(listRef) {
    const l = findList(listRef);
    if (!l) { print('<span class="err">List not found.</span>'); return; }
    print('─── <b>'+l.title+'</b> <span class="dim">('+l.id+')</span> ───');
    if (!l.items.length) { print('<span class="dim">[no items]</span>'); return; }
    l.items.forEach(it => {
      print((it.done ? '✓' : '◻︎') + '  ['+it.id+'] ' + it.text + (it.done ? ' <span class="dim">('+it.done_at+')</span>' : ''));
    });
  }
  async function cmd_del_list(target) {
    const i = state.lists.findIndex(x => x.id === target || x.title.toLowerCase() === target.toLowerCase());
    if (i === -1) { print('<span class="err">List not found.</span>'); return; }
    const removed = state.lists.splice(i,1)[0];
    await save();
    print('<span class="ok">Deleted list:</span> '+removed.title);
  }

  async function cmd_export() {
    const exportObj = {
      meta: { app: "Terminal List", version: VERSION, exported_at: nowISO() },
      data: state
    };
    download('terminal-list-export.json', JSON.stringify(exportObj, null, 2));
    print('<span class="ok">Exported JSON.</span>');
  }
  async function cmd_import(mode='merge') {
    return new Promise(resolve => {
      fileEl.onchange = async e => {
        const file = e.target.files[0];
        if (!file) return resolve();
        const text = await file.text();
        try {
          const obj = JSON.parse(text);
          if (!obj || !obj.data) throw new Error('Invalid file');
          const incoming = obj.data;
          if (mode === 'replace') {
            state = incoming;
          } else {
            // merge: concat notes/lists; simple de-dupe by id
            const mapNote = new Map(state.notes.map(n => [n.id, n]));
            for (const n of incoming.notes || []) { mapNote.set(n.id, n); }
            state.notes = Array.from(mapNote.values()).sort((a,b)=> (b.updated||b.created||'').localeCompare(a.updated||a.created||''));
            const mapList = new Map(state.lists.map(l => [l.id, l]));
            for (const l of incoming.lists || []) { mapList.set(l.id, l); }
            state.lists = Array.from(mapList.values());
          }
          await save();
          print('<span class="ok">Import '+mode+' complete.</span>');
        } catch (err) {
          print('<span class="err">Import failed:</span> '+err.message);
        } finally { fileEl.value = ""; resolve(); }
      };
      fileEl.click();
    });
  }

  async function cmd_setpass() {
    const newPass = prompt("Set new passcode (min 4 chars):");
    if (!newPass) { print('<span class="warn">Canceled.</span>'); return; }
    await setPasscode(newPass);
  }
  async function cmd_lock() { lockNow(); }
  async function cmd_unlock() {
    lockUI.style.display = 'flex';
    passInput.focus();
  }
  async function cmd_wipe() {
    const confirm1 = prompt('Type WIPE to confirm emergency data wipe.');
    if (confirm1 === 'WIPE') {
      localStorage.removeItem(APP_KEY);
      print('<span class="ok">Data wiped. Reloading…</span>');
      setTimeout(()=>location.reload(), 300);
    } else {
      print('<span class="warn">Canceled.</span>');
    }
  }

  // ---------------- Command Router ----------------
  async function handleCommand(raw) {
    if (!raw.trim()) return;
    print('<span class="prompt">$</span> <span class="cmd">'+raw.replace(/</g,'&lt;')+'</span>');
    const args = tokenise(raw);
    const cmd = (args.shift() || '').toLowerCase();

    try {
      switch (cmd) {
        case 'help': await cmd_help(); break;

        case 'notes': await cmd_notes(); break;
        case 'note': await cmd_note(args); break;
        case 'open':
          if (args[0] !== 'note' || !args[1]) { print('<span class="err">Usage: open note &lt;id|title&gt;</span>'); break; }
          await cmd_open_note(args.slice(1).join(' ')); break;
        case 'write':
          if (args[0] !== 'note' || args.length < 3) { print('<span class="err">Usage: write note &lt;id|title&gt; "text"</span>'); break; }
          await cmd_write_note(args[1], args.slice(2).join(' ').replace(/^["']|["']$/g,'')); break;
        case 'del':
          if (args[0] === 'note') { await cmd_del_note(args.slice(1).join(' ')); }
          else if (args[0] === 'list') { await cmd_del_list(args.slice(1).join(' ')); }
          else { print('<span class="err">Usage: del note|list &lt;id|title&gt;</span>'); }
          break;

        case 'lists': await cmd_lists(); break;
        case 'list': await cmd_list(args); break;
        case 'add':
          if (args.length < 2) { print('<span class="err">Usage: add &lt;list&gt; "item"</span>'); break; }
          await cmd_add(args[0], args.slice(1).join(' ').replace(/^["']|["']$/g,'')); break;
        case 'done':
          if (args.length < 2) { print('<span class="err">Usage: done &lt;list&gt; &lt;itemId&gt;</span>'); break; }
          await cmd_done(args[0], args[1]); break;
        case 'show':
          if (args.length < 1) { print('<span class="err">Usage: show &lt;list&gt;</span>'); break; }
          await cmd_show(args[0]); break;

        case 'export': await cmd_export(); break;
        case 'import': await cmd_import(args[0]==='replace' ? 'replace' : 'merge'); break;

        case 'setpass': await cmd_setpass(); break;
        case 'lock': await cmd_lock(); break;
        case 'unlock': await cmd_unlock(); break;
        case 'wipe': await cmd_wipe(); break;

        default:
          print('<span class="warn">Unknown command.</span> Type <span class="kbd">help</span>.');
      }
    } catch (err) {
      print('<span class="err">Error:</span> '+err.message);
    }
  }

  // ---------------- Wire up UI ----------------
  inputEl.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      const v = inputEl.value;
      inputEl.value = "";
      handleCommand(v);
    }
  });
  $("#btnHelp").onclick = () => handleCommand('help');
  $("#btnExport").onclick = () => handleCommand('export');
  $("#btnImport").onclick = () => handleCommand('import');
  $("#btnLock").onclick = () => handleCommand('lock');
  $("#btnWipe").onclick = () => handleCommand('wipe');

  $("#btnUnlock").onclick = async () => {
    try {
      await attemptUnlock(passInput.value);
      passInput.value = '';
      lockMsg.textContent = '';
      if (consoleEl.childElementCount === 0) printHeader();
    } catch (e) {
      lockMsg.textContent = e.message;
    }
  };
  $("#btnCancel").onclick = () => { lockUI.style.display = 'none'; };

  // ---------------- Init ----------------
  (async function init(){
    const ok = await load();
    if (ok) { printHeader(); }
    inputEl.focus();
  })();
  </script>
</body>
</html>
